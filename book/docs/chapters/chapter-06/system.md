System

An Isaac‑centred robotics system composes several coordinated services: an Isaac Sim scene runner (USD), dataset exporters, a model training pipeline, and a deployment/runtime stack. The Isaac Sim runner executes physics and rendering on GPU, exposing sensor streams and scene state via the Isaac ROS bridge or custom publishers. A dataset exporter records synchronized frames, depth, segmentation masks, and object poses, packaging them for the training pipeline. The training pipeline consumes these assets and produces serialized models (PyTorch checkpoints, TensorRT engines) that are then packaged for ROS 2 deployment.

Isaac’s USD scene graph promotes modularity: separate USD layers for static scene geometry, randomized assets, and per‑trial parameters allow efficient composition and parallelized generation. Use the Isaac Sim Python API to orchestrate randomized trials, change materials and lighting procedurally, and capture per‑frame metadata including random seeds and renderer settings. Implement a manifest format (JSON) that records USD layer URIs, random seeds, renderer settings, and GPU driver versions so every run is auditable and reproducible.

Physically grounded example: build a conveyor‑belt inspection scene in Isaac Sim. Place parts with randomized poses on the conveyor, enable realistic contact physics for collisions, and configure a camera with depth and RGB sensors. Export synchronized sensor streams and segmentation masks, train an inspection network using mixed‑precision on a GPU cluster, and deploy the model using TensorRT in a ROS 2 node that subscribes to the real camera feed for inference. During HIL validation, run short supervised trials and compare per‑frame segmentation IoU and model latency against acceptance thresholds.

Operational trade‑offs and invariants: Isaac Sim offers higher photorealism and GPU‑accelerated pipelines but requires careful management of render budgets and GPU driver compatibility. For dynamics‑only studies, headless Gazebo remains more efficient. Design the system so that physics and rendering responsibilities can be split across workers — use Isaac for photoreal rendering and a headless engine for physics prefiltering when throughput matters. Always version USD assets, manifest files, and container images.