Concept

A digital twin in robotics is a rigorously specified, executable model of a physical platform and its environment that couples kinematics, dynamics, perceptual sensors, and the on‑board software stack. Unlike a visualization or static CAD model, a twin is intended for closed‑loop experimentation: controllers send commands to the twin, sensors emit realistic observations, and repeatable experiments produce measurable outputs that can be directly compared to the real system. The twin’s value lies in two properties: (1) grounded physical fidelity — an explicit representation of mass, inertia, actuator dynamics, contact geometry, sensor optics, and noise characteristics; and (2) software parity — identical or behaviorally equivalent middleware topics, frame transforms, parameter sets, and control interfaces so the same ROS 2 nodes can run against simulation or hardware with minimal change.

Designing a twin requires explicit modeling choices and acceptance criteria. Choose which sub‑systems require high fidelity (e.g., manipulator dynamics for force control) versus where statistical realism suffices (e.g., photorealism for RGB training). Track model provenance: URDF/Xacro sources, SDF worlds, sensor plugin parameters, and ros2 launch manifests. Define parity metrics early (pose RMSE, joint effort residuals, perception precision/recall) and incorporate them into the twin’s validation harness so the twin is continuously calibrated and versioned.

Physically grounded example: to twin a 6‑DOF industrial manipulator used for bin picking, author a URDF with accurate inertial parameters and collision geometry, enable ros2_control controllers mapping to both simulated and hardware interfaces, and attach a simulated Intel RealSense profile in Gazebo for depth and RGB. Run identical pick‑and‑place sequences on the real robot and the twin, record rosbag2 archives, and compute per‑step pose and wrench RMSE. Use Unity (ROS‑TCP‑Connector) to produce photorealistic RGB renders for training a perception model while retaining Gazebo physics for contact realism. This composition demonstrates how targeted fidelity domains (Gazebo for contact/dynamics, Unity for imaging) produce a twin that is both useful and tractable for iteration.

Constraints and caveats: a twin is an approximation — model error, friction and compliance mismatches, unmodelled sensor artifacts, and network latency can produce significant divergence. Treat the twin as an instrument: log assumptions, quantify uncertainty, and calibrate frequently. Acceptance criteria for this chapter require each tab to provide explicit, testable guidance and at least one grounded example using Gazebo, Unity, ROS 2, or Isaac.